TOKEN = "8462784979:AAEahcMwQmZH_dS8tFrKN14eLrth-8gJDCo"
ADMIN_ID = 8506444186

DISCORD_WEBHOOK = "https://discord.com/api/webhooks/1351146941235859579/CLhqzrUnhb2fyrnJXrXDKP9mbCZkiZu6mJlInPe3kBmBdC2UTVlpStoCwvgXKTP8_Ia4"

REWARD = 1.00
MIN_WITHDRAW = 50.00
DAILY_LIMIT = 5

MATH_QUESTIONS = [
    {"q": "What is 15 + 28?", "choices": ["43", "42", "44", "41"], "answer": "43"},
    {"q": "What is 9 Ã— 7?", "choices": ["56", "63", "72", "54"], "answer": "63"},
    {"q": "What is 100 Ã· 4?", "choices": ["20", "30", "25", "15"], "answer": "25"},
    {"q": "What is 45 - 18?", "choices": ["27", "28", "26", "25"], "answer": "27"},
    {"q": "What is 12 Ã— 12?", "choices": ["124", "144", "134", "154"], "answer": "144"},
    {"q": "What is 56 + 37?", "choices": ["92", "94", "93", "91"], "answer": "93"},
    {"q": "What is 81 Ã· 9?", "choices": ["8", "7", "10", "9"], "answer": "9"},
    {"q": "What is 7 Ã— 8?", "choices": ["54", "56", "58", "52"], "answer": "56"},
    {"q": "What is 200 - 67?", "choices": ["133", "143", "123", "153"], "answer": "133"},
    {"q": "What is 25 Ã— 4?", "choices": ["90", "110", "100", "80"], "answer": "100"},
    {"q": "What is 144 Ã· 12?", "choices": ["11", "13", "12", "14"], "answer": "12"},
    {"q": "What is 33 + 47?", "choices": ["70", "80", "90", "75"], "answer": "80"},
    {"q": "What is 15 Ã— 6?", "choices": ["80", "85", "90", "95"], "answer": "90"},
    {"q": "What is 500 - 235?", "choices": ["265", "275", "255", "285"], "answer": "265"},
    {"q": "What is 72 Ã· 8?", "choices": ["8", "9", "7", "10"], "answer": "9"},
    {"q": "What is 18 + 24?", "choices": ["40", "42", "44", "38"], "answer": "42"},
    {"q": "What is 11 Ã— 11?", "choices": ["111", "121", "131", "101"], "answer": "121"},
    {"q": "What is 64 Ã· 8?", "choices": ["6", "7", "8", "9"], "answer": "8"},
    {"q": "What is 99 - 33?", "choices": ["66", "56", "76", "86"], "answer": "66"},
    {"q": "What is 13 Ã— 5?", "choices": ["55", "60", "65", "70"], "answer": "65"},
]

JUMBLE_QUESTIONS = [
    {"q": "Unscramble: PPHILIPPINES", "choices": ["PHILIPPINES", "SINGAPORE", "MALAYSIA", "INDONESIA"], "answer": "PHILIPPINES"},
    {"q": "Unscramble: ANINMAL", "choices": ["ANIMAL", "MINERAL", "PLANT", "OBJECT"], "answer": "ANIMAL"},
    {"q": "Unscramble: TLEPHONE", "choices": ["TELEPHONE", "COMPUTER", "KEYBOARD", "MONITOR"], "answer": "TELEPHONE"},
    {"q": "Unscramble: CMOPUTER", "choices": ["PRINTER", "SCANNER", "COMPUTER", "SPEAKER"], "answer": "COMPUTER"},
    {"q": "Unscramble: BEAITUFUL", "choices": ["BEAUTIFUL", "WONDERFUL", "COLORFUL", "POWERFUL"], "answer": "BEAUTIFUL"},
    {"q": "Unscramble: RSEATUARNT", "choices": ["SUPERMARKET", "RESTAURANT", "HOSPITAL", "PHARMACY"], "answer": "RESTAURANT"},
    {"q": "Unscramble: CHCOLOTAE", "choices": ["VANILLA", "CARAMEL", "CHOCOLATE", "STRAWBERRY"], "answer": "CHOCOLATE"},
    {"q": "Unscramble: UNEVIRTSIY", "choices": ["COLLEGE", "SCHOOL", "ACADEMY", "UNIVERSITY"], "answer": "UNIVERSITY"},
    {"q": "Unscramble: ARIPALNE", "choices": ["AIRPLANE", "HELICOPTER", "SPACESHIP", "SUBMARINE"], "answer": "AIRPLANE"},
    {"q": "Unscramble: BREKAFSAT", "choices": ["LUNCH", "BREAKFAST", "DINNER", "SNACK"], "answer": "BREAKFAST"},
    {"q": "Unscramble: EDCUATINO", "choices": ["VACATION", "EDUCATION", "GRADUATION", "CELEBRATION"], "answer": "EDUCATION"},
    {"q": "Unscramble: GVOERNMNET", "choices": ["PARLIAMENT", "GOVERNMENT", "PRESIDENT", "CONGRESS"], "answer": "GOVERNMENT"},
    {"q": "Unscramble: ADEVNTURE", "choices": ["ADVENTURE", "TREASURE", "PLEASURE", "MEASURE"], "answer": "ADVENTURE"},
    {"q": "Unscramble: CELERBATION", "choices": ["VACATION", "DECORATION", "CELEBRATION", "EDUCATION"], "answer": "CELEBRATION"},
    {"q": "Unscramble: TECHOLNOGY", "choices": ["BIOLOGY", "TECHNOLOGY", "PSYCHOLOGY", "SOCIOLOGY"], "answer": "TECHNOLOGY"},
    {"q": "Unscramble: HSOPITAL", "choices": ["HOSPITAL", "PHARMACY", "CLINIC", "LABORATORY"], "answer": "HOSPITAL"},
    {"q": "Unscramble: SICSORS", "choices": ["STAPLER", "SCISSORS", "RULER", "ERASER"], "answer": "SCISSORS"},
    {"q": "Unscramble: UMBRLELA", "choices": ["RAINCOAT", "JACKET", "UMBRELLA", "SWEATER"], "answer": "UMBRELLA"},
    {"q": "Unscramble: BTUTERFYL", "choices": ["DRAGONFLY", "BUTTERFLY", "LADYBUG", "HONEYBEE"], "answer": "BUTTERFLY"},
    {"q": "Unscramble: ELPHANTE", "choices": ["GIRAFFE", "ELEPHANT", "RHINOCEROS", "HIPPOPOTAMUS"], "answer": "ELEPHANT"},
]

LOGO_QUESTIONS = [
    {"q": "Guess this brand!", "img": "https://upload.wikimedia.org/wikipedia/commons/thumb/a/a9/Amazon_logo.svg/1200px-Amazon_logo.svg.png", "choices": ["eBay", "Amazon", "Alibaba", "Shopee"], "answer": "Amazon"},
    {"q": "Guess this brand!", "img": "https://upload.wikimedia.org/wikipedia/commons/thumb/2/2f/Google_2015_logo.svg/1200px-Google_2015_logo.svg.png", "choices": ["Google", "Yahoo", "Bing", "DuckDuckGo"], "answer": "Google"},
    {"q": "Guess this brand!", "img": "https://upload.wikimedia.org/wikipedia/commons/thumb/0/08/Netflix_2015_logo.svg/1200px-Netflix_2015_logo.svg.png", "choices": ["Hulu", "HBO", "Netflix", "Disney+"], "answer": "Netflix"},
    {"q": "Guess this brand!", "img": "https://upload.wikimedia.org/wikipedia/commons/thumb/b/b9/Spotify_logo.svg/1200px-Spotify_logo.svg.png", "choices": ["Apple Music", "YouTube Music", "SoundCloud", "Spotify"], "answer": "Spotify"},
    {"q": "Guess this brand!", "img": "https://upload.wikimedia.org/wikipedia/commons/thumb/a/a5/Instagram_icon.png/600px-Instagram_icon.png", "choices": ["Instagram", "Snapchat", "TikTok", "Pinterest"], "answer": "Instagram"},
    {"q": "Guess this brand!", "img": "https://upload.wikimedia.org/wikipedia/commons/thumb/6/6f/Logo_of_Twitter.svg/1200px-Logo_of_Twitter.svg.png", "choices": ["Facebook", "Twitter", "LinkedIn", "Threads"], "answer": "Twitter"},
    {"q": "Guess this brand!", "img": "https://upload.wikimedia.org/wikipedia/commons/thumb/c/cd/Facebook_logo_%28square%29.png/600px-Facebook_logo_%28square%29.png", "choices": ["Messenger", "WhatsApp", "Facebook", "Meta"], "answer": "Facebook"},
    {"q": "Guess this brand!", "img": "https://upload.wikimedia.org/wikipedia/commons/thumb/f/f9/Coca-Cola_logo.svg/1200px-Coca-Cola_logo.svg.png", "choices": ["Pepsi", "Sprite", "Fanta", "Coca-Cola"], "answer": "Coca-Cola"},
    {"q": "Guess this brand!", "img": "https://upload.wikimedia.org/wikipedia/commons/thumb/4/44/Microsoft_logo.svg/1200px-Microsoft_logo.svg.png", "choices": ["Microsoft", "Windows", "Apple", "IBM"], "answer": "Microsoft"},
    {"q": "Guess this brand!", "img": "https://upload.wikimedia.org/wikipedia/commons/thumb/f/fa/Apple_logo_black.svg/800px-Apple_logo_black.svg.png", "choices": ["Samsung", "Apple", "Huawei", "Sony"], "answer": "Apple"},
    {"q": "Guess this brand!", "img": "https://upload.wikimedia.org/wikipedia/commons/thumb/2/26/Shopee_logo.svg/1200px-Shopee_logo.svg.png", "choices": ["Lazada", "Zalora", "Shopee", "Carousell"], "answer": "Shopee"},
    {"q": "Guess this brand!", "img": "https://upload.wikimedia.org/wikipedia/commons/thumb/a/ad/Grab_logo.svg/1200px-Grab_logo.svg.png", "choices": ["Uber", "Lyft", "Gojek", "Grab"], "answer": "Grab"},
    {"q": "Guess this brand!", "img": "https://upload.wikimedia.org/wikipedia/commons/thumb/0/09/YouTube_full-color_icon_%282017%29.svg/1200px-YouTube_full-color_icon_%282017%29.svg.png", "choices": ["YouTube", "Vimeo", "Twitch", "TikTok"], "answer": "YouTube"},
    {"q": "Guess this brand!", "img": "https://upload.wikimedia.org/wikipedia/commons/thumb/6/6b/WhatsApp.svg/600px-WhatsApp.svg.png", "choices": ["Telegram", "WhatsApp", "Viber", "WeChat"], "answer": "WhatsApp"},
    {"q": "Guess this brand!", "img": "https://upload.wikimedia.org/wikipedia/commons/thumb/8/83/Telegram_2019_Logo.svg/600px-Telegram_2019_Logo.svg.png", "choices": ["Signal", "Line", "Telegram", "Discord"], "answer": "Telegram"},
    {"q": "Guess this brand!", "img": "https://upload.wikimedia.org/wikipedia/commons/thumb/2/20/LG_symbol.svg/800px-LG_symbol.svg.png", "choices": ["Samsung", "Sony", "LG", "Panasonic"], "answer": "LG"},
    {"q": "Guess this brand!", "img": "https://upload.wikimedia.org/wikipedia/commons/thumb/2/24/Samsung_Logo.svg/1200px-Samsung_Logo.svg.png", "choices": ["Samsung", "Huawei", "Xiaomi", "Oppo"], "answer": "Samsung"},
    {"q": "Guess this brand!", "img": "https://upload.wikimedia.org/wikipedia/commons/thumb/a/a6/Logo_NIKE.svg/1200px-Logo_NIKE.svg.png", "choices": ["Adidas", "Nike", "Puma", "Reebok"], "answer": "Nike"},
    {"q": "Guess this brand!", "img": "https://upload.wikimedia.org/wikipedia/commons/thumb/2/20/Adidas_Logo.svg/1200px-Adidas_Logo.svg.png", "choices": ["Nike", "Adidas", "Under Armour", "New Balance"], "answer": "Adidas"},
    {"q": "Guess this brand!", "img": "https://upload.wikimedia.org/wikipedia/commons/thumb/3/3a/McDonald%27s_Golden_Arches.svg/800px-McDonald%27s_Golden_Arches.svg.png", "choices": ["Burger King", "Wendy's", "McDonald's", "KFC"], "answer": "McDonald's"},
]

import json, os, random, asyncio, requests
from datetime import datetime, date
from telegram import Update, InlineKeyboardButton as Btn, InlineKeyboardMarkup as KB
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, MessageHandler, filters, ContextTypes

DB_FILE = "database.json"
DIVIDER = "â•" * 25

def load_db():
    if os.path.exists(DB_FILE):
        with open(DB_FILE, "r") as f:
            return json.load(f)
    return {"users": {}, "withdrawals": []}

def save_db(data):
    with open(DB_FILE, "w") as f:
        json.dump(data, f, indent=2)

def get_user(user_id):
    db = load_db()
    uid = str(user_id)
    today = str(date.today())
    if uid not in db["users"]:
        db["users"][uid] = {"name": "", "username": "", "balance": 0.0, "total_earned": 0.0, "correct": 0, "wrong": 0, "joined": today, "answered": {"math": [], "jumble": [], "logo": []}, "daily": {"date": today, "math": 0, "jumble": 0, "logo": 0}, "withdrawals": []}
        save_db(db)
    user = db["users"][uid]
    if user["daily"]["date"] != today:
        user["daily"] = {"date": today, "math": 0, "jumble": 0, "logo": 0}
        save_db(db)
    return user

def update_user(user_id, data):
    db = load_db()
    db["users"][str(user_id)] = data
    save_db(db)

def peso(amount):
    return f"â‚±{amount:,.2f}"

def send_discord_webhook(user_name, amount, gcash_number, user_id):
    try:
        data = {"embeds": [{"title": "ğŸ€ New Withdrawal Request!", "color": 16761035, "fields": [{"name": "ğŸ‘¤ User", "value": user_name, "inline": True}, {"name": "ğŸ†” User ID", "value": str(user_id), "inline": True}, {"name": "ğŸ’° Amount", "value": peso(amount), "inline": True}, {"name": "ğŸ“± GCash Number", "value": gcash_number, "inline": True}, {"name": "ğŸ“… Date", "value": datetime.now().strftime("%Y-%m-%d %H:%M:%S"), "inline": True}, {"name": "â³ Status", "value": "Pending (2-3 working days)", "inline": True}], "footer": {"text": "Coquette Q&A Bot ğŸ€"}, "timestamp": datetime.utcnow().isoformat()}]}
        requests.post(DISCORD_WEBHOOK, json=data)
    except Exception as e:
        print(f"Discord webhook error: {e}")

def dashboard_text(user):
    accuracy = (user['correct'] / (user['correct'] + user['wrong']) * 100) if (user['correct'] + user['wrong']) > 0 else 0
    remaining_math = DAILY_LIMIT - user['daily']['math']
    remaining_jumble = DAILY_LIMIT - user['daily']['jumble']
    remaining_logo = DAILY_LIMIT - user['daily']['logo']
    return f"""
ğŸ€âœ¨ *COQUETTE EARNINGS* âœ¨ğŸ€
{DIVIDER}

ğŸ‘¤ *{user['name']}*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ’• *YOUR WALLET*
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ğŸ’° Balance: *{peso(user['balance'])}*
â”‚  ğŸ† Total Earned: {peso(user['total_earned'])}
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ğŸ“Š *STATISTICS*
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  âœ… Correct: {user['correct']}
â”‚  âŒ Wrong: {user['wrong']}
â”‚  ğŸ¯ Accuracy: {accuracy:.1f}%
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ğŸŒ¸ *TODAY'S LIMIT*
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ğŸ”¢ Math: {remaining_math}/{DAILY_LIMIT} left
â”‚  ğŸ”¤ Jumble: {remaining_jumble}/{DAILY_LIMIT} left
â”‚  ğŸ–¼ Logo: {remaining_logo}/{DAILY_LIMIT} left
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

{DIVIDER}
ğŸ©° _Earn {peso(REWARD)} per correct answer!_
"""

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    u = update.effective_user
    user = get_user(u.id)
    user["name"] = u.first_name or "User"
    user["username"] = u.username or ""
    update_user(u.id, user)
    keyboard = [[Btn("ğŸ® START EARNING ğŸ®", callback_data="earn_menu")], [Btn("ğŸ’° Balance", callback_data="balance"), Btn("ğŸ’¸ Withdraw", callback_data="withdraw")], [Btn("ğŸ“Š Statistics", callback_data="stats"), Btn("ğŸ† Leaderboard", callback_data="leaderboard")], [Btn("â“ How to Play", callback_data="help")]]
    await update.message.reply_text(dashboard_text(user), parse_mode="Markdown", reply_markup=KB(keyboard))

async def show_dashboard(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    u = update.effective_user
    user = get_user(u.id)
    keyboard = [[Btn("ğŸ® START EARNING ğŸ®", callback_data="earn_menu")], [Btn("ğŸ’° Balance", callback_data="balance"), Btn("ğŸ’¸ Withdraw", callback_data="withdraw")], [Btn("ğŸ“Š Statistics", callback_data="stats"), Btn("ğŸ† Leaderboard", callback_data="leaderboard")], [Btn("â“ How to Play", callback_data="help")]]
    await query.edit_message_text(dashboard_text(user), parse_mode="Markdown", reply_markup=KB(keyboard))

async def earn_menu(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    u = update.effective_user
    user = get_user(u.id)
    remaining_math = DAILY_LIMIT - user['daily']['math']
    remaining_jumble = DAILY_LIMIT - user['daily']['jumble']
    remaining_logo = DAILY_LIMIT - user['daily']['logo']
    text = f"""
ğŸ€âœ¨ *CHOOSE YOUR GAME* âœ¨ğŸ€
{DIVIDER}

ğŸŒ¸ Select a category to start earning!
ğŸ’• Each correct answer = *{peso(REWARD)}*

ğŸ“Œ *Daily Limit: {DAILY_LIMIT} questions each*

{DIVIDER}
"""
    keyboard = [[Btn(f"ğŸ”¢ Math Solver ({remaining_math} left)", callback_data="game_math")], [Btn(f"ğŸ”¤ Jumbled Words ({remaining_jumble} left)", callback_data="game_jumble")], [Btn(f"ğŸ–¼ Guess the Logo ({remaining_logo} left)", callback_data="game_logo")], [Btn("ğŸ  Back to Home", callback_data="home")]]
    await query.edit_message_text(text, parse_mode="Markdown", reply_markup=KB(keyboard))

async def start_game(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    game_type = query.data.replace("game_", "")
    u = update.effective_user
    user = get_user(u.id)
    if user['daily'][game_type] >= DAILY_LIMIT:
        text = f"""
ğŸ€ *DAILY LIMIT REACHED* ğŸ€
{DIVIDER}

ğŸ˜¢ You've used all {DAILY_LIMIT} questions for this category today!

â° Come back tomorrow for more!

ğŸ’¡ *Tip:* Try other categories!
{DIVIDER}
"""
        keyboard = [[Btn("ğŸ”™ Back to Games", callback_data="earn_menu")], [Btn("ğŸ  Home", callback_data="home")]]
        await query.edit_message_text(text, parse_mode="Markdown", reply_markup=KB(keyboard))
        return
    if game_type == "math":
        questions = MATH_QUESTIONS
        answered = user['answered']['math']
        emoji = "ğŸ”¢"
        title = "MATH SOLVER"
    elif game_type == "jumble":
        questions = JUMBLE_QUESTIONS
        answered = user['answered']['jumble']
        emoji = "ğŸ”¤"
        title = "JUMBLED WORDS"
    else:
        questions = LOGO_QUESTIONS
        answered = user['answered']['logo']
        emoji = "ğŸ–¼"
        title = "GUESS THE LOGO"
    available = [i for i in range(len(questions)) if i not in answered]
    if not available:
        text = f"""
ğŸ€ *ALL DONE!* ğŸ€
{DIVIDER}

ğŸ‰ Amazing! You've completed all questions in this category!

ğŸ’• Check back later for new questions!
{DIVIDER}
"""
        keyboard = [[Btn("ğŸ”™ Back to Games", callback_data="earn_menu")], [Btn("ğŸ  Home", callback_data="home")]]
        await query.edit_message_text(text, parse_mode="Markdown", reply_markup=KB(keyboard))
        return
    context.user_data['game_type'] = game_type
    loading_frames = [f"ğŸ€ *{title}* ğŸ€\n\nâ³ Generating question...\n\nâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘ 0%", f"ğŸ€ *{title}* ğŸ€\n\nâ³ Generating question...\n\nâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘ 20%", f"ğŸ€ *{title}* ğŸ€\n\nâ³ Generating question...\n\nâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘ 40%", f"ğŸ€ *{title}* ğŸ€\n\nâœ¨ Preparing your question...\n\nâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘ 60%", f"ğŸ€ *{title}* ğŸ€\n\nâœ¨ Preparing your question...\n\nâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘ 80%", f"ğŸ€ *{title}* ğŸ€\n\nğŸŒ¸ Almost ready...\n\nâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 100%"]
    delay = random.uniform(10, 15)
    frame_delay = delay / len(loading_frames)
    for frame in loading_frames:
        try:
            await query.edit_message_text(frame, parse_mode="Markdown")
            await asyncio.sleep(frame_delay)
        except:
            pass
    q_index = random.choice(available)
    q = questions[q_index]
    context.user_data['current_q'] = q_index
    question_num = user['daily'][game_type] + 1
    choices = q['choices'].copy()
    random.shuffle(choices)
    if game_type == "logo":
        text = f"""
ğŸ€ *{title}* ğŸ€
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“Œ Question {question_num}/{DAILY_LIMIT}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

{emoji} *{q['q']}*

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ’• +{peso(REWARD)} if correct!
"""
        keyboard = [[Btn(f"ğŸ”˜ {choices[0]}", callback_data=f"ans_{game_type}_{q_index}_{choices[0]}")], [Btn(f"ğŸ”˜ {choices[1]}", callback_data=f"ans_{game_type}_{q_index}_{choices[1]}")], [Btn(f"ğŸ”˜ {choices[2]}", callback_data=f"ans_{game_type}_{q_index}_{choices[2]}")], [Btn(f"ğŸ”˜ {choices[3]}", callback_data=f"ans_{game_type}_{q_index}_{choices[3]}")], [Btn("ğŸ  Quit", callback_data="earn_menu")]]
        try:
            await query.message.delete()
            await context.bot.send_photo(chat_id=update.effective_chat.id, photo=q['img'], caption=text, parse_mode="Markdown", reply_markup=KB(keyboard))
        except Exception as e:
            await context.bot.send_message(chat_id=update.effective_chat.id, text=text + f"\n\nğŸ”— [View Logo]({q['img']})", parse_mode="Markdown", reply_markup=KB(keyboard))
    else:
        text = f"""
ğŸ€ *{title}* ğŸ€
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“Œ Question {question_num}/{DAILY_LIMIT}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

{emoji} *{q['q']}*

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ’• +{peso(REWARD)} if correct!
"""
        keyboard = [[Btn(f"ğŸ”˜ {choices[0]}", callback_data=f"ans_{game_type}_{q_index}_{choices[0]}")], [Btn(f"ğŸ”˜ {choices[1]}", callback_data=f"ans_{game_type}_{q_index}_{choices[1]}")], [Btn(f"ğŸ”˜ {choices[2]}", callback_data=f"ans_{game_type}_{q_index}_{choices[2]}")], [Btn(f"ğŸ”˜ {choices[3]}", callback_data=f"ans_{game_type}_{q_index}_{choices[3]}")], [Btn("ğŸ  Quit", callback_data="earn_menu")]]
        await query.edit_message_text(text, parse_mode="Markdown", reply_markup=KB(keyboard))

async def handle_answer(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    data = query.data
    parts = data.split("_", 3)
    game_type = parts[1]
    q_index = int(parts[2])
    user_answer = parts[3]
    u = update.effective_user
    user = get_user(u.id)
    if q_index in user['answered'][game_type]:
        await query.answer("âš ï¸ Already answered!", show_alert=True)
        return
    if game_type == "math":
        questions = MATH_QUESTIONS
    elif game_type == "jumble":
        questions = JUMBLE_QUESTIONS
    else:
        questions = LOGO_QUESTIONS
    correct = questions[q_index]['answer']
    is_correct = user_answer == correct
    user['answered'][game_type].append(q_index)
    user['daily'][game_type] += 1
    if is_correct:
        user['balance'] += REWARD
        user['total_earned'] += REWARD
        user['correct'] += 1
        text = f"""
ğŸ€âœ¨ *CORRECT!* âœ¨ğŸ€
{DIVIDER}

ğŸ‰ Amazing job, {user['name']}!

âœ… Your answer: *{user_answer}*

ğŸ’° +{peso(REWARD)} earned!

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ’• Balance: *{peso(user['balance'])}*
ğŸ“Š Today: {user['daily'][game_type]}/{DAILY_LIMIT} questions
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
"""
    else:
        user['wrong'] += 1
        text = f"""
ğŸ€ *WRONG!* ğŸ€
{DIVIDER}

ğŸ˜¢ Better luck next time!

âŒ Your answer: *{user_answer}*
âœ… Correct answer: *{correct}*

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“Š Today: {user['daily'][game_type]}/{DAILY_LIMIT} questions
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
"""
    update_user(u.id, user)
    remaining = DAILY_LIMIT - user['daily'][game_type]
    if remaining > 0:
        keyboard = [[Btn("â–¶ï¸ Next Question", callback_data=f"game_{game_type}")], [Btn("ğŸ”™ Other Games", callback_data="earn_menu"), Btn("ğŸ  Home", callback_data="home")]]
    else:
        keyboard = [[Btn("ğŸ”™ Other Games", callback_data="earn_menu"), Btn("ğŸ  Home", callback_data="home")]]
    try:
        await query.edit_message_caption(text, parse_mode="Markdown", reply_markup=KB(keyboard))
    except:
        try:
            await query.edit_message_text(text, parse_mode="Markdown", reply_markup=KB(keyboard))
        except:
            await context.bot.send_message(chat_id=update.effective_chat.id, text=text, parse_mode="Markdown", reply_markup=KB(keyboard))

async def show_balance(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    u = update.effective_user
    user = get_user(u.id)
    text = f"""
ğŸ€âœ¨ *YOUR WALLET* âœ¨ğŸ€
{DIVIDER}

ğŸ’° *Current Balance*
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    *{peso(user['balance'])}*
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ğŸ† *Total Earned*
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    {peso(user['total_earned'])}
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

{DIVIDER}
ğŸ’¸ Minimum withdrawal: {peso(MIN_WITHDRAW)}
ğŸ“± Withdraw via: GCash
"""
    keyboard = [[Btn("ğŸ’¸ Withdraw Now", callback_data="withdraw")], [Btn("ğŸ® Earn More", callback_data="earn_menu")], [Btn("ğŸ  Home", callback_data="home")]]
    await query.edit_message_text(text, parse_mode="Markdown", reply_markup=KB(keyboard))

async def show_stats(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    u = update.effective_user
    user = get_user(u.id)
    total_answers = user['correct'] + user['wrong']
    accuracy = (user['correct'] / total_answers * 100) if total_answers > 0 else 0
    text = f"""
ğŸ€âœ¨ *YOUR STATISTICS* âœ¨ğŸ€
{DIVIDER}

ğŸ‘¤ *{user['name']}*
ğŸ“… Joined: {user['joined']}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ’° *EARNINGS*
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Balance: {peso(user['balance'])}
â”‚  Total: {peso(user['total_earned'])}
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ğŸ“Š *PERFORMANCE*
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  âœ… Correct: {user['correct']}
â”‚  âŒ Wrong: {user['wrong']}
â”‚  ğŸ¯ Accuracy: {accuracy:.1f}%
â”‚  ğŸ“ Total: {total_answers} answers
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ğŸŒ¸ *QUESTIONS ANSWERED*
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ğŸ”¢ Math: {len(user['answered']['math'])}
â”‚  ğŸ”¤ Jumble: {len(user['answered']['jumble'])}
â”‚  ğŸ–¼ Logo: {len(user['answered']['logo'])}
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

{DIVIDER}
"""
    keyboard = [[Btn("ğŸ® Play Now", callback_data="earn_menu")], [Btn("ğŸ  Home", callback_data="home")]]
    await query.edit_message_text(text, parse_mode="Markdown", reply_markup=KB(keyboard))

async def show_leaderboard(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    db = load_db()
    users_list = [(uid, data) for uid, data in db['users'].items()]
    users_list.sort(key=lambda x: x[1]['total_earned'], reverse=True)
    text = f"""
ğŸ€âœ¨ *LEADERBOARD* âœ¨ğŸ€
{DIVIDER}

ğŸ† *TOP EARNERS*

"""
    medals = ["ğŸ¥‡", "ğŸ¥ˆ", "ğŸ¥‰", "4ï¸âƒ£", "5ï¸âƒ£", "6ï¸âƒ£", "7ï¸âƒ£", "8ï¸âƒ£", "9ï¸âƒ£", "ğŸ”Ÿ"]
    for i, (uid, data) in enumerate(users_list[:10]):
        medal = medals[i] if i < len(medals) else f"{i+1}."
        name = data.get('name', 'User')[:15]
        earned = peso(data.get('total_earned', 0))
        text += f"{medal} *{name}* â€” {earned}\n"
    if not users_list:
        text += "No players yet! Be the first! ğŸŒŸ"
    text += f"\n{DIVIDER}"
    keyboard = [[Btn("ğŸ® Play Now", callback_data="earn_menu")], [Btn("ğŸ  Home", callback_data="home")]]
    await query.edit_message_text(text, parse_mode="Markdown", reply_markup=KB(keyboard))

async def show_help(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    text = f"""
ğŸ€âœ¨ *HOW TO PLAY* âœ¨ğŸ€
{DIVIDER}

ğŸ“Œ *STEP 1:* Tap "Start Earning"

ğŸ“Œ *STEP 2:* Choose a game:
   ğŸ”¢ Math Solver - Solve equations
   ğŸ”¤ Jumbled Words - Unscramble words
   ğŸ–¼ Guess the Logo - Identify brands

ğŸ“Œ *STEP 3:* Tap the correct answer!

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ’° *EARNINGS*
â€¢ Each correct answer = {peso(REWARD)}
â€¢ Daily limit: {DAILY_LIMIT} questions/category

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ’¸ *WITHDRAWAL*
â€¢ Minimum: {peso(MIN_WITHDRAW)}
â€¢ Method: GCash only
â€¢ Processing: 2-3 working days

{DIVIDER}
ğŸ©° _Good luck and have fun!_
"""
    keyboard = [[Btn("ğŸ® Start Playing!", callback_data="earn_menu")], [Btn("ğŸ  Home", callback_data="home")]]
    await query.edit_message_text(text, parse_mode="Markdown", reply_markup=KB(keyboard))

async def withdraw_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    u = update.effective_user
    user = get_user(u.id)
    if user['balance'] < MIN_WITHDRAW:
        needed = MIN_WITHDRAW - user['balance']
        text = f"""
ğŸ€ *INSUFFICIENT BALANCE* ğŸ€
{DIVIDER}

ğŸ˜¢ You need more to withdraw!

ğŸ’° Your balance: {peso(user['balance'])}
ğŸ“Œ Minimum: {peso(MIN_WITHDRAW)}
âŒ Need: {peso(needed)} more

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ’• Keep playing to earn more!
{DIVIDER}
"""
        keyboard = [[Btn("ğŸ® Earn More", callback_data="earn_menu")], [Btn("ğŸ  Home", callback_data="home")]]
    else:
        text = f"""
ğŸ€âœ¨ *WITHDRAWAL* âœ¨ğŸ€
{DIVIDER}

ğŸ’° Available: *{peso(user['balance'])}*
ğŸ“± Method: *GCash*

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ“ *Please send your details:*

`GCash Number, Amount`

*Example:*
`09171234567, 100`

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
â³ Processing: 2-3 working days
{DIVIDER}
"""
        context.user_data['withdrawing'] = True
        keyboard = [[Btn("âŒ Cancel", callback_data="home")]]
    await query.edit_message_text(text, parse_mode="Markdown", reply_markup=KB(keyboard))

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not context.user_data.get('withdrawing'):
        return
    text = update.message.text
    u = update.effective_user
    user = get_user(u.id)
    try:
        parts = text.replace(" ", "").split(",")
        if len(parts) != 2:
            raise ValueError("Invalid format")
        gcash_number = parts[0]
        amount = float(parts[1])
        if not gcash_number.startswith("09") or len(gcash_number) != 11:
            await update.message.reply_text("âŒ Invalid GCash number! Must be 11 digits starting with 09.")
            return
        if amount < MIN_WITHDRAW:
            await update.message.reply_text(f"âŒ Minimum withdrawal is {peso(MIN_WITHDRAW)}!")
            return
        if amount > user['balance']:
            await update.message.reply_text(f"âŒ Insufficient balance! You only have {peso(user['balance'])}.")
            return
        user['balance'] -= amount
        user['withdrawals'].append({"amount": amount, "gcash": gcash_number, "date": str(datetime.now()), "status": "pending"})
        update_user(u.id, user)
        context.user_data['withdrawing'] = False
        send_discord_webhook(user['name'], amount, gcash_number, u.id)
        success_text = f"""
ğŸ€âœ¨ *WITHDRAWAL SUBMITTED!* âœ¨ğŸ€
{DIVIDER}

âœ… *Request Successful!*

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ’° Amount: *{peso(amount)}*
ğŸ“± GCash: *{gcash_number}*
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

â³ *Processing Time:*
2-3 working days

ğŸ’• *Remaining Balance:*
{peso(user['balance'])}

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ©° Thank you for using our bot!
{DIVIDER}
"""
        keyboard = [[Btn("ğŸ® Keep Earning", callback_data="earn_menu")], [Btn("ğŸ  Home", callback_data="home")]]
        await update.message.reply_text(success_text, parse_mode="Markdown", reply_markup=KB(keyboard))
    except ValueError:
        await update.message.reply_text("âŒ *Invalid format!*\n\nPlease use:\n`GCash Number, Amount`\n\nExample:\n`09171234567, 100`", parse_mode="Markdown")

async def admin_panel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != ADMIN_ID:
        await update.message.reply_text("âŒ Admin only!")
        return
    db = load_db()
    total_users = len(db['users'])
    total_balance = sum(u.get('balance', 0) for u in db['users'].values())
    total_earned = sum(u.get('total_earned', 0) for u in db['users'].values())
    pending_withdrawals = sum(1 for u in db['users'].values() for w in u.get('withdrawals', []) if w.get('status') == 'pending')
    text = f"""
ğŸ‘‘ *ADMIN PANEL* ğŸ‘‘
{DIVIDER}

ğŸ“Š *STATISTICS*
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ğŸ‘¥ Users: {total_users}
â”‚  ğŸ’° Total Balance: {peso(total_balance)}
â”‚  ğŸ† Total Earned: {peso(total_earned)}
â”‚  â³ Pending: {pending_withdrawals}
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

{DIVIDER}
"""
    await update.message.reply_text(text, parse_mode="Markdown")

async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    data = query.data
    if data != "withdraw" and context.user_data.get('withdrawing'):
        context.user_data['withdrawing'] = False
    if data == "home":
        await show_dashboard(update, context)
    elif data == "earn_menu":
        await earn_menu(update, context)
    elif data.startswith("game_"):
        await start_game(update, context)
    elif data.startswith("ans_"):
        await handle_answer(update, context)
    elif data == "balance":
        await show_balance(update, context)
    elif data == "withdraw":
        await withdraw_start(update, context)
    elif data == "stats":
        await show_stats(update, context)
    elif data == "leaderboard":
        await show_leaderboard(update, context)
    elif data == "help":
        await show_help(update, context)

def main():
    print("ğŸ€ Starting Coquette Q&A Bot...")
    app = Application.builder().token(TOKEN).build()
    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("admin", admin_panel))
    app.add_handler(CallbackQueryHandler(button_handler))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
    print("âœ… Bot is running!")
    print("ğŸ©° Coquette Q&A Earning Bot Active!")
    app.run_polling()

if __name__ == "__main__":
    main()
